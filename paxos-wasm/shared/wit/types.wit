interface paxos-types {
    record run-config {
        is-event-driven: bool,          // Toggles the fire-and-forget or the waiting and handling of messages synchronously.
        acceptors-send-learns: bool,    // Toggle if the leader proposer or the acceptors should send the learns to the learners.
        learners-send-executed: bool,   // Toggle if the learners should send the executed message to all proposers or not.
        prepare-timeout: u64,           // The timeout period before trying a new prepare-phase in ms e.g., 5000 for 5 seconds.
        demo-client: bool,              // Enables a simulated demo client by creating client requests at an interval in the respective server.
        tick-ms: u64,                   // The tickrate in ms which is the minimum wait time in-between ticks and run_paxos_loop calls.
        client-server-port: u16         // The port the client connects to on the leaders address.
        // ... Add more?
    } 

    enum paxos-phase {
        start,
        prepare-send,
        prepare-pending,
        accept-commit,
        stop,
        crash,
    }

    enum paxos-role {
        coordinator,
        proposer,
        acceptor,
        learner,
        client,
    }

    record node {
        node-id: u64,
        address: string,
        role: paxos-role,
    }

    type slot = u64;
    type ballot = u64;

    type kv-key = string;
    type kv-value = string;

    record kv-pair {
        key: kv-key,
        value: kv-value,
    }
 
    variant operation{
        get(kv-key),
        set(kv-pair),
        remove(kv-key),
        clear,
        demo,
    }

    type cmd = option<operation>;
    type cmd-result = option<kv-value>;

    /// Represents the command or operation to be executed.
    record value {
        command: cmd,   // The actual command, executed by the state machine (if any)
        client-id: string,
        client-seq: u64,
    }

    record client-request {
        // TODO: Add more if needed
        // return-address: string;
        // timestamp: u64,
        value: value,
    }

    record client-response {
        client-id: string,
        client-seq: u64,
        success: bool,
        command-result: cmd-result,
    }

    /// A proposal generated by the leader.
    record proposal {
        slot: slot,
        ballot: ballot,
        value: value,
    }

    /// Prepare message sent by the proposer to initiate a new proposal.
    /// Acceptors respond to this message with a promise.
    record prepare {
        slot: slot,  // Optional, the acceptors only send accepts with a slot higher than this
        ballot: ballot,
    }

    /// Promise message returned by an acceptor in response to a prepare.
    record promise {
        slot: slot,
        ballot: ballot,
        accepted: list<p-value>,
    }

    /// Pâ€‘value represents already accepted proposals from an acceptor. (Change name?)
    record p-value {
        slot: slot,
        ballot: ballot,
        value: option<value>,
    }

    /// Accept message sent by the proposer to ask acceptors to accept a proposal.
    record accept {
        slot: slot,
        ballot: ballot,
        value: value,
    }

    /// An accepted response from an acceptor to an accept.
    record accepted {
        slot: u64,
        ballot: u64,
        success: bool,
    }

    /// Learn message used by acceptors to notify that a proposal has been chosen,
    /// or by the leader to commit a value.
    record learn {
        slot: slot,
        value: value,
    }

    record execute-result {
        value: value,
        slot: slot,
        success: bool,
        cmd-result: cmd-result,
    }

    record executed {
        results: list<execute-result>,
        adu: slot,
    }
}

interface proposer-types {
    use paxos-types.{slot, ballot, value, client-request, proposal};

    /// Result type for the prepare phase.
    enum prepare-result {
        success,                    // Improve?
        quorum-failure,             // Not enough promise responses were received
        is-event-driven,            // We will handle the result later
    }

    /// Result type for the accept phase.
    variant accept-result {
        accepted(u64),          // Quorum of acceptors accepted with the number of acceptances.
        missing-proposal,       // There was no in-flight proposals matching the slot
        quorum-failure,         // Not enough accept responses were received
        is-event-driven,        // We will handle the result later
    }

    /// Status of a proposal in the Proposer-Agent.
    enum proposal-status {
        in-flight,         // Phase-1 done, waiting for accepts
        chosen,            // Quorum of accepts received, now chosen
        commit-pending,    // Learn sent to learners, waiting execution
        finalized,         // Executed and ready to reply to client
    }

    /// A single proposal plus its current status.
    record proposal-entry {
        proposal: proposal,
        status: proposal-status,
    }

    /// The overall state of the proposer.
    record proposer-state {
        is-leader: bool,
        num-acceptors: u64,

        current-slot: slot,
        current-ballot: ballot,
        
        pending-client-requests: list<value>,
        proposals: list<proposal-entry>,  
    }
}

interface acceptor-types {
    use paxos-types.{slot, ballot, value, promise, accepted, p-value};

    /// Result type for a prepare request.
    variant promise-result {
        promised(promise),
        rejected(ballot),
    }

    /// Result type for an accept request.
    variant accepted-result {
        accepted(accepted),
        rejected(ballot),
    }

    // This record holds the highest ballot promised for a given slot.
    record promise-entry {
        slot: slot,
        ballot: ballot,
    }

    record acceptor-state {
        promises: list<ballot>,
        accepted: list<p-value>,
    }

}

interface learner-types {
    use paxos-types.{slot, value, learn, accept};

    variant learn-result {
        execute(list<learned-entry>),
        ignore,
    }

    record learned-entry {
        slot: slot,
        value: value,
    }

    variant retry-learn-result {
        no-gap,
        skip(slot),
        retry(slot),
    }

    record learner-state {
        learned: list<learned-entry>,
    }
}

interface network-types {
    use paxos-types.{slot, paxos-role, node, prepare, promise, accept, accepted, learn, value, executed, client-response};

    variant message-payload {
        ignore,                             // No-op.
        client-request(value),              // A client request.
        client-response(client-response),   // A client response.
        prepare(prepare),                   // A prepare request.
        promise(promise),                   // A promise response.
        accept(accept),                     // An accept request.
        accepted(accepted),                 // An accepted response.
        learn(learn),                       // A learn request.
        // learn-ack(learn),                // A learn ack. // TODO: Use or not to use, with custom payload? 
        heartbeat(heartbeat),               // Heartbeat.
        executed(executed),                 // Contains list of executed values and adu.
        retry-learn(slot),                  // Retry learn for missing slot
    }

    record heartbeat {
        sender: node,
        timestamp: u64,
    }

    record network-message {
        sender: node,
        // targets: paxos-role, // TODO: Do we want to specify a specific target group?
        payload: message-payload,
    }

}