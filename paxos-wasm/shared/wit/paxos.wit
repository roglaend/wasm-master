package paxos:default;

/// The core proposer contains all Paxos logic for proposals.
interface proposer {
    use paxos-types.{slot, ballot, value, client-request, proposal, promise, accepted};
    use proposer-types.{prepare-result, accept-result, proposer-state};

    resource proposer-resource {
        /// Constructs a new proposer with an initial ballot, number of acceptors, and leadership flag.
        constructor(is-leader: bool, num-acceptors: u64, init-ballot: ballot);

        /// Returns the current state of the proposer.
        get-state: func() -> proposer-state;

        /// Enqueues a client request for later processing.
        enqueue-client-request: func(request: client-request) -> bool;

        /// Retrieves the up-to-date proposal for the given slot, if exists.
        get-proposal: func(slot: slot) -> option<proposal>;

        /// Creates the next proposal from the pending queue (if available).
        create-proposal: func() -> option<proposal>;

        /// Processes a complete set of promise responses for a given slot.
        process-prepare: func(slot: slot, promises: list<promise>) -> prepare-result;

        /// Processes a complete set of accepted responses for a given slot.
        process-accept: func(slot: slot, accepts: list<accepted>) -> accept-result;

        /// Finalizes the proposal with the chosen value.
        /// If the chosen value differs from the client’s original request, the original value is re-enqueued.
        finalize-proposal: func(slot: slot, chosen-value: value) -> bool;

        /// Transitions this proposer into leader mode.
        become-leader: func() -> bool;

        /// Relinquishes leadership.
        resign-leader: func() -> bool;
    }
}

interface acceptor {
    use paxos-types.{slot, ballot, value, learn, promise, accepted};
    use acceptor-types.{promise-result, accepted-result, acceptor-state};


    resource acceptor-resource {
        constructor(gc-window: option<u64>);
        get-state: func() -> acceptor-state;
        prepare: func(slot: slot, ballot: ballot) -> promise-result;
        accept: func(slot: slot, ballot: ballot, value: value) -> accepted-result;
    }
}

interface learner {
    use paxos-types.{slot, value};
    use learner-types.{learned-entry, learner-state};

    resource learner-resource {
        constructor();
        get-state: func() -> learner-state;
        learn: func(slot: slot, value: value);
        get-learned: func(slot: slot) -> option<learned-entry>;
    }
}

interface kv-store {
    use paxos-types.{value};
    use kv-store-types.{key, kv-pair, operation};

    resource kv-store-resource {
        constructor();

        // Get the value for a key.
        get: func(key: key) -> option<value>;

        // Set a key to a value.
        set: func(key: key, value: value);

        // Remove a key.
        remove: func(key: key) -> option<value>;

        // Clear all keys.
        clear: func();

        // Return the current state as a list of key/value pairs.
        get-state: func() -> list<kv-pair>;

        // Return the history as a list of operations.
        get-history: func() -> list<operation>;
    }
}

interface network {
    use paxos-types.{node};
    use network-types.{network-message};

    send-hello: func() -> string;
    send-message: func(nodes: list<node>, message: network-message) -> list<network-message>;
}

interface paxos-coordinator {
    use paxos-types.{node, slot, ballot, client-request, value};
    use proposer-types.{prepare-result, accept-result};
    use network-types.{network-message};
    use learner-types.{learned-entry, learn-result};
    use kv-store-types.{kv-pair};

    record election-result {
        leader: node,
        quorum: u64,
    }

    record paxos-state {
        learned: list<learned-entry>,
        kv-state: list<kv-pair>,
    }

    resource paxos-coordinator-resource {
        constructor(node: node, nodes: list<node>, is-leader: bool);

        /// Optionally, elects a leader.
        elect-leader: func() -> election-result;

        /// Phase 1: Prepare Phase.
        prepare-phase: func(slot: slot, ballot: ballot) -> prepare-result;
        
        /// Phase 2: Accept Phase.
        accept-phase: func(proposal-value: value, slot: slot, ballot: ballot) -> accept-result;
        
        /// Phase 3: Commit Phase.
        commit-phase: func(slot: slot) -> option<learn-result>;

        /// Handles network messages.
        handle-message: func(message: network-message) -> network-message;

        /// Retrieves the currently learned value.
        get-learned-value: func() -> value;

        /// Orchestrates the entire Paxos protocol.
        run-paxos: func(request: client-request) -> bool;

        /// Expose the current Paxos state (learned results and kv-store).
        get-state: func() -> paxos-state;
    } 
}

interface logger {
    enum level {
        debug,
        info,
        warn,
        error,
    }
    // log: func(level: level, msg: string); 

    log-debug: func(msg: string);
    log-info: func(msg: string);
    log-warn: func(msg: string);
    log-error: func(msg: string);
}

// interface client {
//     send-request: func(value: string) -> bool;
//     get-response: func() -> option<string>;
// }


/// THIS IS FOR THE MODULAR GRPC MODEL ///

interface proposer-agent {
    use paxos-types.{node, slot, ballot, client-request, value, proposal, prepare, promise, accept, accepted};
    use proposer-types.{prepare-result, accept-result};
    use network-types.{network-message};

    resource proposer-agent-resource {
        /// Constructs a new proposer agent given this node’s id and the list of all cluster nodes.
        constructor(node: node, nodes: list<node>, is-leader: bool);

        /// Submits a client request to the system.
        submit-client-request: func(request: client-request) -> bool;

        /// Retrieves the up-to-date proposal for the given slot from the core proposer, if exists.
        get-proposal: func(slot: slot) -> option<proposal>;

        /// Create the next proposal using the core proposer (if any)
        create-proposal: func() -> option<proposal>;

        /// Initiates a full round of Paxos from the leader’s perspective.
        run-paxos: func(client-request: client-request) -> bool; // TODO: Remove input argument when decoupled with submit-client-request

        /// Broadcasts prepare messages and merges optional local promise payloads with remote responses,
        /// then invokes the core proposer’s process-prepare.
        prepare-phase: func(slot: slot, ballot: ballot, promises: list<promise>) -> prepare-result;

        /// Broadcasts accept messages and merges optional local accepted payloads with remote responses,
        /// then invokes the core proposer’s process-accept.
        accept-phase: func(proposal-value: value, slot: slot, ballot: ballot, accepts: list<accepted>) -> accept-result;

        /// Finalizes the proposal with the chosen value.
        finalize-proposal: func(slot: slot, chosen-value: value) -> bool;

        /// Handles incoming network messages relevant to the proposer.
        handle-message: func(message: network-message) -> network-message;
    }
}

interface acceptor-agent {
    use paxos-types.{node, slot, ballot, value};
    use acceptor-types.{promise-result, accepted-result};
    use learner-types.{learn-result};
    use network.{network-message};

    resource acceptor-agent-resource {
        constructor(node: node, nodes: list<node>, send-learns: bool);
        
        process-prepare: func(slot: slot, ballot: ballot) -> promise-result;

        process-accept: func(slot: slot, ballot: ballot, value: value) -> accepted-result;

        commit-phase: func(slot: slot, value: value) -> option<learn-result>;

        handle-message: func(message: network-message) -> network-message; // Note that they only care about a subset of the message types
    }

}

interface learner-agent {
    use paxos-coordinator.{paxos-state};
    use network.{network-message};

    resource learner-agent-resource {
        constructor();

        /// Retrieves the most recently learned value (if any). Change this to be per ballot/slot
        get-learned-value: func() -> option<string>;

        /// Returns a snapshot of the full Paxos state (e.g. learned entries, kv-store state).
        get-state: func() -> paxos-state;

        /// Processes incoming network messages (such as commit notifications and accepted responses).
        handle-message: func(message: network-message) -> network-message; // Note that they only care about a subset of the message types
    }

}


