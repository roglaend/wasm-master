use anyhow::{Context, Result};
use exports::paxos::proposer::proposer::ProposerState;
use simple_paxos_wasm_utils::{
    bind_interfaces_needed_by_guest_rust_std, get_component_linker_store, ComponentRunStates,
};
use std::path::PathBuf;
use wasmtime::component::ResourceAny;
use wasmtime::{Engine, Store};

// Import WIT-generated bindings for proposer, acceptor, and learner
wasmtime::component::bindgen!({
    world: "proposer-world",
    path: "../paxos-wasm/proposer/wit/proposer.wit",
    // exports: "proposer"
});

// wasmtime::component::bindgen!({
//     world: "acceptor-world",
//     path: "../paxos-wasm/acceptor/wit/acceptor.wit",
// });

// wasmtime::component::bindgen!({
//     world: "learner-world",
//     path: "../paxos-wasm/learner/wit/learner.wit",
// });

pub struct PaxosWasmRuntime {
    pub store: Store<ComponentRunStates>,
    pub proposer_bindings: ProposerWorld, // Generated by bindgen!
}

impl PaxosWasmRuntime {
    pub fn new(engine: &Engine) -> Result<Self> {
        let target_dir = PathBuf::from("target/wasm32-wasip2/release");
        let proposer_path = target_dir.join("proposer.wasm");

        // Load the component and create the linker/store
        let (component, mut linker, mut store) = get_component_linker_store(
            engine,
            proposer_path.to_str().context("Invalid proposer path")?,
            "",
        )?;

        // Bind WASI interfaces for std support
        bind_interfaces_needed_by_guest_rust_std(&mut linker);

        // Instantiate the proposer component
        let proposer_bindings = ProposerWorld::instantiate(&mut store, &component, &linker)
            .context("Failed to instantiate proposer component")?;

        Ok(Self {
            store,
            proposer_bindings,
        })
    }

    /// **Creates a proposer instance (resource)**
    pub fn create_proposer_instance(&mut self, num_acceptors: u64) -> Result<ResourceAny> {
        self.proposer_bindings
            .paxos_proposer_proposer()
            .proposer_resource()
            .call_constructor(&mut self.store, num_acceptors)
            .context("Failed to create proposer instance")
    }

    /// **Propose a value using an existing proposer instance**
    pub fn propose(
        &mut self,
        proposer_handle: ResourceAny,
        proposal_id: u64,
        value: String,
    ) -> Result<bool> {
        self.proposer_bindings
            .paxos_proposer_proposer()
            .proposer_resource()
            .call_propose(&mut self.store, proposer_handle, proposal_id, &value)
            .context("Failed to call 'propose' function")
    }

    pub fn get_state(&mut self, proposer_handle: ResourceAny) -> Result<ProposerState> {
        self.proposer_bindings
            .paxos_proposer_proposer()
            .proposer_resource()
            .call_get_state(&mut self.store, proposer_handle)
            .context("Failed to call 'propose' function")
    }
}
